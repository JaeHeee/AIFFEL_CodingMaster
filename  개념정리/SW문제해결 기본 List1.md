# SW문제해결 기본 List1

## 알고리즘
>***알고리즘이란?***   
유한한 단계를 통해 문제를 해결하기 
위한 절차나 방법

**좋은 알고리즘**   
정확성, 작업량, 메모리 사용량, 단순성, 최적성 측면에서 좋아야 한다.

**시간복잡도**   
시간복잡도란 알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수를 말한다.
Big O 표기법을 이용하여 표현한다.

<br>

## List
> ***List?***   
같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

<br>

## Exhaustive Search
> ***Exhaustive Search*?**   
문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

1. Brute-fore 기법이라고도 한다.
2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
3. 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
5. 주어진 문제를 풀 때, 우선 완전 탐색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다. 

<br>

## Greedy Algorithm
> ***Greedy Algorithm?***   
여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달

1. 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
2. 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.

**Greedy Algorithm 수행 과정**   
1. 해 선택   
    >현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다.

2. 실행 가능성 검사
    >새로운 부분 해 집합이 실행 가능한지를 확인한다.   
    문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사
    >새로운 부분 해 집합이 문제의 해가 되는지를 확인한다.   
    아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작한다.