# Sort Algoritm

## Sort Algorithm
>***Sort Algorithm?***   
주어진 데이터를 사용자가 지정한 기준에 맞게 정렬하는 알고리즘

<br>

## Selection Sort
> ***Selection Sort?***   
가장 직관적인 접근 방법으로, 전체 데이터중 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘

**시간복잡도**   
O(N^2)

<br>

## Bubble Sort
> ***Bubble Sort?***  
바로 옆에 있는 데이터와 비교하여, 더 작은 값을 앞으로 보내는 알고리즘

**시간복잡도**   
O(N^2)

<br>

## Insertion Sort
> ***Insertion Sort?***  
앞부분에서부터 차례대로 이미 정렬되어있는 부분과 비교하여, 현재 데이터를 적절한 위치에 삽입하는 알고리즘

**시간복잡도**   
O(N^2)

<br>

## Quick Sort
> ***Quick Sort?***  
분할정복 방식을 사용하여, 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나누면서 정렬하는 알고리즘  

**알고리즘**  
1. 리스트에서 한 요소를 pivot으로 지정한다.
2. pivot을 기준으로 pivot보다 작은 요소들은 모두 pivot의 왼쪽으로, 큰 요소들은 모두 pivot의 오른쪽으로 옮겨진다.
3. pivot을 제외한 왼쪽과 오른쪽 리스트를 다시 정렬한다.
4. 이러한 과정을 더이상 분할이 불가능할 때까지, 계속 반복해서 진행한다.

**시간복잡도**   
O(N*logN)

<br>

## Counting Sort
> ***Counting Sort?***  
범위 조건이 주어진 경우에 한해서 굉장히 빠른 알고리즘으로, 단순하게 크기를 기준으로 개수를 세는 알고리즘

**알고리즘**  
1. 데이터를 정렬기준의 크기별로 개수를 파악한다.
2. 파악된 개수만큼 순서대로 결과를 보여준다.

**시간복잡도**   
O(N)

<br>

## Merge Sort
> ***Merge Sort?***  
분할정복 방식으로, 우선 반으로 나누고, 나중에 합치는 단계에서 정렬을 하는 알고리즘

**알고리즘**  
1. 계속해서 리스트를 반으로 나눠준다.
2. 다시 리스트를 병합하면서 정렬을 진행한다.

**시간복잡도**   
O(N*logN)

<br>

## Heap Sort
> ***Heap Sort?***  
힙 트리구조를 이용한는 정렬 알고리즘

**Heap**  

최소값이나 최대값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리
- 최대힙은 부모노드가 자식노드보다 큰 힙
- 최소힙은 부모노드가 자식노드보다 작은 힙

**Heapify Algorithm**  
특정한 하나의 노드에 대해서 수행하는 것으로 하나의 노드를 제외하고는 최대힙이 구성되어있는 상태라고 가정한다.  
특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘이다.

**알고리즘**  
1. 정렬해야하는 데이터에 대해서 Heapify Algorithm을 이용하여 힙 구조를 만든다.
2. root에 있는 데이터를 가장 뒤를 보내준다.
3. 나머지 데이터에 대해서도, 위의 과정을 반복한다.

**시간복잡도**   
O(N*logN)